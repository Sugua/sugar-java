##### 重写equals()时必须重写hashCode()方式



-  equals方法判断两个对象是相等的， 那这两个对象的hashCode值也要相等
-  两个对象有相同的hash值， 他们也比一定相等的（哈希碰撞）

##### Java中只有值传递

###### 值传递&引用传递

- 值传递：方法接受的是实参值的拷贝， 回创建副本
- 引用传递：方法接受的直接子啊实参所引用的对象在堆中的地址，不会创建副本，对形参修改讲影响到实参

###### Java中是值传递

- 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。

## 


#####RandomAccess接口



- `RandomAccess`接口并没有什么定义，所以`RamdomAccess`不过是标识，标识实现这个接口的类具有随机访问功能
- `ArrayList`实现了`RamdomAccess`接口，而`LinkedList`没有实现，为什么呢？和底层的数据接口有关，`ArrayList`底层是数组，而LinkedList底层是链表。数组天生是支持随机访问的，时间复杂度为O(1),链表只有遍历到特定的位置才能访问特定的元素，时间复杂度为O(n),索尼不支持快速随机访问。


######无序性和不可重复性
- 无序性不等于随机性，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。
- 不可重复性是指添加的元素按照`equals()`判断时，返回false，需要重写`equals()`方法和`hashCode()`方法


######比较`HashSet`、LinkedHashSet、TreeSet

- 三者都是`Set`的实现类，都能保证元素唯一，并且都是现场不安全的
- 三者的主要区别在于底层数据结构不同。`HashSet`底层结构是哈希表（给予`HashSet`实现）。`LinkedHashSet`的底层是链表和哈希表，元素的插入和取出顺序满足FIFO。	`TreeSet`底层数据接口是红黑树，元素是有序的，排序的方式有自然顺序和定制顺序
- 底层数据结构不同导致这三者的应用场景不同。`HashSet`用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet`用于保证元素的插入和取出顺序满足FIFO的场景。`TreeSet`用于支持元素自定义顺序规则的场景

